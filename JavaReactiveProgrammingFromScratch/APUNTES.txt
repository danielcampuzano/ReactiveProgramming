-> USING THREADS IS NOT SCALABLE IF YOU HAVE FOR EXAMPLE A LOT OF IOPs because the thread is blocked and will continue blocked until the operation finishes. It is not scalable and you need many resources

-> With cloud it is use to use autoscaling but it is not the best solution.

***********************EVENT DRIVEN************************
- There will be an event loop, usually one thread per CPU call.
- Every time a request comes in it is added into the que (It doesn't exist, it's just for a better understanding)
-> Event loop reads the task from the que and execute it and will not wait for the result to arrive, then it continues with another task.
-> When the response is ready the loop is notified and the callback (task to be executed with the answer) is placed in the que and then executed by the event loop.

--> IT IS NOT THE BEST WAY TO READ AND MAINTAIN.

********* TYPES OF IO MODELS **********************

1. Sync + blocking -> Used most of the time.
2. Async -> A thread delegates another thread that makes all the process and then notifies
3. Non-blocking -> The OS notified our thread that our task is done
4. Async + Non-blocking

**************REACTIVE STREAMS***************************
Twitter, Netflix, entre otros -> 2014 --> Specification

-> It is based on the observer pattern: A person publish a twit and its followers can see it, if the followers retwit it their followers are notified and can see it as well.

-> Observe and react!

-> THE REACTIVE STREAMS IS A SET OF INTERFACES:
- Publisher
- Subscriber 
- Subscription
- Processor -> Can act both like a publisher and a subscriber

***************REACTIVE PROGRAMMING*******************************
Subset / Special case of event driven / asynchronous programming

-> You register a set of callbacks or listeners to be exceuted as soon as data goes through that pipeline or chain
-> It´s a declarative data-flow programming

****************************PILLLARS
-> Asynchronous data processing
-> Non-blocking
-> Functional Style / Declarative

**********************PUBLISHER - Subscriber *************************
- A SUBSCRIBER wants to ge updates from the PUBLISHER
- PUBLISHER has subscribe method that lets the PUBLISHER receives a SUBSCRIBER
- When the PUBLISHER accepts the request of the SUBSCRIBER he hands over the SUBSCRIPTION object to the SUBSCRIBER
-> With the onsubscribe method the SUBSCRIBER can talk to the PUBLISHER
-> The PUBLISHER sends data using the ON NEXT method from the SUBSCRIBER
-> The PUBLISHER calls the ON COMPLETE method the PUBLISHER won't send any more data to the subscriber.

*TERMINOLOGY

PUBLISHER -> Source, observable, producer, upstream

SUBSCRIBER -> Sink, observer, downstream, consumer

****MONO(PUBLISHER) -> Emits 0 or 1 item followed by ONCOMPLETE or ONERROR
****FLUX (PUBLISHER)-> Emits 0 or N items followed by ONCOMPLETE or ONERROR

Mono when you are sure there´s only one item expected otherwise Flux

*************************************************************************************************************************
**************************************************OPERATORS**************************************************************************************
*************************************************************************************************************************

HANDLE -> filter + map

DO HOOKS -> CALLBACKS

LIMIT RATE -> Subscriber asks for 400 items with a limit rate of 100 - when 75 objects are received the subscriber asks for more items 

SWITCH IF EMPTY -> I define a fallback -> So for example if I ask the cache and it doesn't return any value so I can ask the directly to the DB.

TRANSFORM -> When you want to reuse steps -> You can build steps separated and then reuse it

SWITCH ON FIRST -> You ask for the first item and if it is in the expected format it continues, but if not it switches to another operation an then continues with the pipeline.

MAP -> Is usually one by one, you send an object and you get another one

FLAT MAP -> It is not one by one, it flattens all the objects


**********************************************************************************************************************************************
************************************************THREADING AND SCHEDULERS**********************************************************************
**********************************************************************************************************************************************

--> Usually the process of publisher, subscriber, handling the subscription happens on the same thread.

-> You can execute tasks asynchronously using Schedulers method :
-boundedElastic - network, time consuming calls 
- parallel - CPU intensive tasks
- single - a single dedicated thread for one-off tasks
- immediate - current thread

*****WHEN YOU HAVE MULTIPLE SUBSCRIBE ON the closest to the publisher will have precedence.
****WHEN you expose a Flux you should add subscribeOn in order to expose it asynchronously

******OPERATORS**************************************************************************************
- SUBSCRIBEON -> For Upstream (From bottom to top) -> It launches a new thread -> the closest to the publisher will have precedence -> Affects the SOURCE
- PUBLISHON -> For Downstream (From top to bottom) -> It will swith to another thread pool as soon as it finds the publish on

*****************************************************TAKE A LOOK**************************************************************
SCHEDULERS != PARALELL EXECUTION
All the operation are always executed in sequential
Data is processed one by one via 1 thread in the ThreadPool for a Subscriber
SCHEDULERS.parallel is a thread pool for CPU tasks -> Doesn´t mean paralell execution

Every subscriber will have a thread, but it is different than saying that every operation occurs in a different thread

************************************ PARALELL EXECUTION ******************************************
- By default things are executed sequentially one by one a the publisher publish items
****OPERATORS
- paralell 
- runOn

You need to know what you are doing -> For example if you are adding to a List (which is not threadsafe) in parallel it won´t work as expected.

*********************************************************************************************************************
***********************************SINKS*****************************************************************************
*********************************************************************************************************************
You can emmit signals manually -> And send when you want
You can emmit signals from various threads

-> A sink is both a publisher and a subscriber --> Sinks are better alternatives to procesors and very easy to use
-> A sink can also be exposed as a mono and a Flux

- Sinks.one() -> Is a mono  --> You can use sink.asMono()
- Sinks.Many() -> sink.asFlux()

************************************************************************************************************************
**************************************BACK PRESSURE OVER FLOW STRATEGY**************************************************
************************************************************************************************************************

What happens if the producer produces 10000 items per second but the pipeline can process 1 item per second??

*************************************************************************************************************************
**************************************UNIT TESTING STEP VERIFIER*********************************************************
*************************************************************************************************************************




**************MY CONCLUSIONS
- Reactive programming doesnt mean paralellism, by default it doesnt work like that.
- Reactive programming means that threads are not blocked, so you subscribeon(schedulers.boundedElastic) means that a new thread will be created to execute the operations and the main thread will not be blocked so that it can continue performing other operations required by the program.
- So what are really the advantages and when to use reactive programming? --> Which are the apropriate scenarios for using it?

